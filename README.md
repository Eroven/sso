# sso
单点登录实现，使用ActiveMQ作为服务端通信，Redis做一个全局缓存

# 首先整理逻辑
实现单点登录，即多个需要登录的服务端只需登录一次，即可共享用户信息

1. 下意识的动作(主观认为，也是作者的思考过程)
用户在浏览器上请求一个限制性资源(A.html)在服务端A上,A拦截用户请求，发现没有权限，让用户注册权限（一般是登录）；用户登录完成，A将资源A.html发送给户
用户在浏览器上（同一个浏览器）请求一个限制性资源(B.html)在服务端B上,同上
A.html与B.html是有相关性的但不是一个服务端，而且跨域，怎么才能共享用户资源呢？同一个浏览器是不是可以通过Cookie共享来实现呢？
2. 尝试一：在某个服务端登录后创建一个命名为:*USID* 的Cookie,值设置一个UUID，然后将这个Cookie复制多份，设置不同的域名和路径，然后发到用户的浏览器上，当用户请求不同域名下的资源时，服务端检查Cookie中由USID吗？如果有，则说明用户已经登录，拿到用户信息，返回资源。
    如果能将用户信息在不同服务端流转，那么问题看上去就解决了。刚好前两天学习了JMS以及其实现ActiveM，拿来练练（实际上这个项目是在发现了问题，并且刚好学习了一些东西用来练手的）。有了ActiveMQ,用户登录后将用户信息放在一个队列或主题中，将*USID*设置为JMSCorrelationID，这样子就可以筛选出想要的消息。 一些细节问题后面再说，这里只想说，这个尝试失败了，主要原因是：**一个服务端无法发送其他域的Cookie**  当做了一半的时候还挺开心的....(泪流满面)
3. 尝试二：在查阅相关资料后，做出了另一个尝试：采用用户授权中心的方式。
    ### 基本逻辑
    * 用户请求一个限制性资源X.html,不管X.html是哪一个服务端的，拦截后发现未授权，重定向至授权中心AC;
    * 检查是否登录了，如果未登录，那么重定向到登录页面；
    * 存在用户登录后，创建一个全局Session，将用户信息保存在Session中；
    * 创建一个全局Session的ID命名为：*RSESSIONID*，用来辨别不同的session，并将RSESSIONID以Cookie的形式保存在用户浏览器中,这里只需要在授权中心本域下保存就好了；
    * 创建一个命名为TK的票据，以参数的形式重定向请求X.html，服务端拦截，发现有TK，根据TK向授权中心交流，尝试获取用户信息。若获取成功，返回资源X.html
     ### 技术实现
     * 全局Session使用Redis作为缓存，其中key即*RSESSIONID*,且Session失效时间为30m
     * 局部Session即服务端本身的session，例如*java web*的*HttpSession*
     * 服务端X在拥有TK后以ActiveMQ形式向AC交流，其中TK的值即消息中的*JMSCorrelationID*,且每条消息失效时间为30s
     ### 登出
     按理说退出功能是在基本逻辑里面就该设计好的，但是实际上作者在明白了尝试二的可行性后又有点得意了，所以设计时忽略了退出功能，在完成登录功能后才发现少了点什么。这里只是按作者的实际情况来描述，希望作者以后看到这个的时候能够感受到自己的成长，以及作为一个警示。
    * 在每个服务端授权成功将*RSESSIONID*保存到局部session中（不需要保存到Cookie）
    * 拦截器在拦截的时候检查全局Session的存在性，并刷新其存在时间；若全局Session不存在，则摧毁局部Session
    * 退出时将全局Session摧毁，并重定向至授权中心


"Undoes" test